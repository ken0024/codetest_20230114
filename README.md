# codetest_20230114

## はじめに
1/14(土)から実施したプログラミング試験の回答です。  
実装言語はPython 3.10.9 です。

## リポジトリの構成
本リポジトリの構成は下記の通りです。  
`log`ディレクトリ下には生成した監視ログファイル(.csv)と監視対象のサーバのipリスト(.txt)があります。  
`report`ディレクトリ下には各設問の回答で出力されるファイル(.csv)が置かれます。  
```
├── README
├── generate_log.py (監視ログファイル生成用)
├── answer1.py (設問1回答)
├── answer2.py (設問2回答)
├── answer3.py (設問3回答)
├── answer4.py (設問4回答 未実装)
├── [log]
│     ├── watchlist.txt (監視対象のIPリスト)
│     ├── 20200811162253_20200811162543_fixed.csv (テスト用ログファイル)
│     ├── 20200811162253_20200811162543.csv (修正前テスト用ログファイル)
|     :
└── [report]
      ├── report1_*.csv (設問1の回答出力ファイル)
      ├── report2_*.csv (設問2の回答出力ファイル)
      ├── report3_*.csv (設問3の回答出力ファイル, 内容は設問2と同一)
      ├── report3_overload_*.csv (設問3の回答出力ファイル)
      └── report4_*.csv (未実装)

```
## Usage
### watchlist.log

監視対象のIPリストは予め1つのファイル(watchlist.txt)にまとめられているものとします。  
使用したwatchlist.txtは10の監視対象を含み、3つのサブネットから構成されているものとします。 
```
10.20.30.1/16
10.20.30.2/16
192.168.1.20/24
192.168.1.24/24
192.168.1.101/24
192.168.1.102/24
192.168.1.160/24
210.171.136.11/26
210.171.136.12/26
210.171.136.20/26
```
### generateLog.py
監視ログを生成するgenerateLog.pyの実行例を示します。  
generateLog.pyを実行すると、logフォルダ下に任意サイズの監視ログを生成します。 
```generate_log.py   
python .\generate_log.py -d 2020-08-11T16:22:53 -n 12 -i 10
Output: C:\Users\ken\Desktop\fixpoint\codetest_20230114/log/20200811162253_20200811162543.csv

```
オプション引数は以下の通りです
* `-d --date`監視ログの開始時刻を`YYYY-mm-ddTHH:MM:SS`形式で指定します。
* `-n --num`監視ログのipごとの記録回数を指定します。
* `-i --interval`監視ログのping応答の記録間隔(sec)を指定します。

本実装の前提条件として
* 監視ログは`watchlist.txt`のリストの記載順に記録が追加され、終了条件を満たすまでループする
* 監視ログのping応答は監視対象の全サーバで同一の記録間隔(`--interval`)を使用する
とします。
1つ目の前提条件から、監視ログファイルを等間隔に行抽出することで、任意のサーバ(ip)の監視ログを作成することが出来ます。タイムスタンプ(datetime)の扱いや、ping応答時間を1次元配列とみた際の変化点抽出が重要だと感じました。  

  
なお本実装の実行テストには`log/20200811162253_20200811162543_fixed.csv`を使用しています。  
監視ログのping応答時間の長短の重み付けを行う機能の実装を断念したため、
`generateLog.py`で出力されたファイルのping応答時間の項目を設問の処理を反映するため適宜修正したものになります。

### answer*.py
設問1~4の各回答ファイルanswer*.pyの実行例を示します。   
#### 設問1(answer1.py) 
```
PS C:\Users\ken\Desktop\fixpoint\codetest_20230114> python .\answer1.py -f .\log\20200811162253_20200811162543_fixed.csv
10.20.30.1/16,20200811162355,20200811162405
192.168.1.20/24,20200811162435,20200811162535
192.168.1.20/24,20200811162535,20200811162445
192.168.1.101/24,20200811162449,20200811162519
192.168.1.102/24,20200811162409,20200811162346
210.171.136.11/26,20200811162502,20200811162400
```  
オプション引数は以下の通りです
* `-f --file`読み込む監視ログファイルのパス  
   


#### 設問2(answer2.py) 
設問1(answer1.py)を拡張しました。  
```
PS C:\Users\ken\Desktop\fixpoint\codetest_20230114> python .\answer2.py -f .\log\20200811162253_20200811162543_fixed.csv -N 2
['ip', 'datetime_start_timeout', 'datetime_end_timeout']
192.168.1.20/24,20200811162435,20200811162535
192.168.1.101/24,20200811162449,20200811162519
192.168.1.102/24,20200811162409,20200811162346
210.171.136.20/26,20200811162415,20200811162435
```
オプション引数は以下の通りです
* `-f --file`読み込む監視ログファイルのパス
* `-N --numtimeout`故障と判定するタイムアウトの(最小)連続回数

#### 設問3(answer3.py) 
設問2(answer2.py)を拡張しました。 
```
PS C:\Users\ken\Desktop\fixpoint\codetest_20230114> python .\answer3.py -f .\log\20200811162253_20200811162543_fixed.csv -N 2 -m 4 -t 300
```
* `-f --file`読み込む監視ログファイルのパス
* `-m --moverload`過負荷の判定に使用する直近の監視データの個数
* `-t --timeth`過負荷の判定に使用する直近m個の平均記録の閾値(msec)
* `-N --numtimeout`故障と判定するタイムアウトの(最小)連続回数 (設問2)
    
設問2と同様の故障記録ファイル(report3_*.csv)の他に、過負荷状態のサーバの応答記録を抽出したファイル(report3_overload_*.csv)が出力されます。  
README作成時に気づきましたが、過負荷状態も前問の故障記録と同様に、連続する過負荷状態の開始・終了時刻をまとめる形式で出力するべきでした。



#### 設問4(answer4.py)
設問2(answer2.py)を拡張する予定でしたが、実装が間に合いませんでした。  
実装方針のみ記載します。
* ipごとではなく、所属するサブネットごとに監視ログを分割する。
* 時刻$t_p$から$t_l$にかけてサーバ$s_1$~$s_k$の所属するサブネット$N$が故障しているとき、$t_p$と$t_l$は以下の条件を満たしている
  * $t_p$, $t_l$は$N$に所属するサーバ$s_i (i=1,2,...,k)$の、いずれかの故障開始/終了記録から選ばれる
  * $t_p$, $t_l$の時刻は、その記録をもつサーバ以外もすべて故障していなければならないため、$t_a≤t_p<t_b$を満たす故障開始/終了記録($t_a$, $t_b$)がサブネット$N$の監視ログ中に$k-1$個存在する。$t_l$についても同様である
* 条件を満たすサブネットの監視ログ中の故障開始/終了記録を探索する。故障回数の偏りなどの前提条件を設けていないため、$t_p$と$t_l$になり得ない記録を探索の過程で除外していくことが重要だと考えました。